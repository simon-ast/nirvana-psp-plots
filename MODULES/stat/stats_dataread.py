import os
import numpy as np
import astropy.constants as c
import pandas as pd


class PSPStatData:
    def __init__(self, filename, sim_data):
        stat_data = pd.read_json(filename)

        # Correct for maximum distance of simulation data
        # co_index = np.where(raw_data[:, 0] >= sim_data.dist[-1])[0][0]
        # raw_data = raw_data[:co_index]

        # Positional data
        self.dist = stat_data[stat_data["Type"] == "mean"].posR * \
                    1e3 / c.R_sun.value
        # self.num_meas = raw_data[:, 16]

        # Create subclasses which contain necessary stat data
        self.vr = StatDataSplit(stat_data, "vr")
        self.np = StatDataSplit(stat_data, "np")
        self.T = StatDataSplit(stat_data, "Temp")

        # BRIEFLY CALCULATE MASS LOSS RATE (FIX THIS UP)
        class MassLoss:
            def __init__(self, dist, vr, nump):
                self.mean = massloss(dist * c.R_sun.value,
                                     vr.mean * 1e3,
                                     nump.mean * c.m_p.value * 1e6)
                self.stddev = massloss(dist * c.R_sun.value,
                                       vr.stddev * 1e3,
                                       nump.mean * c.m_p.value * 1e6) + \
                              massloss(dist * c.R_sun.value,
                                       vr.mean * 1e3,
                                       nump.stddev * c.m_p.value * 1e6)

        self.massloss = MassLoss(self.dist, self.vr, self.np)

        # RAM PRESSURE
        class RamPressure:
            def __init__(self, vr, nump):
                self.mean = (vr.mean * 1e3) ** 2 * \
                            nump.mean * c.m_p.value * 1e6

                self.stddev = (vr.mean * 1e3) ** 2 * \
                              nump.stddev * c.m_p.value * 1e6 + \
                              2 * (vr.stddev * 1e3) * \
                              nump.mean * c.m_p.value * 1e6

        self.rampressure = RamPressure(self.vr, self.np)


class StatDataSplit:
    """Sub-class to access relevant statistical data"""

    def __init__(self, stat_data, key):
        data_mean = stat_data[stat_data["Type"] == "mean"]
        data_std = stat_data[stat_data["Type"] == "std"]
        data_median = stat_data[stat_data["Type"] == "median"]
        data_q1 = stat_data[stat_data["Type"] == "q1"]
        data_q3 = stat_data[stat_data["Type"] == "q3"]

        self.mean = data_mean[key].reset_index(drop=True)
        self.stddev = data_std[key].reset_index(drop=True)
        self.median = data_median[key].reset_index(drop=True)
        self.q1 = data_q1[key].reset_index(drop=True)
        self.q3 = data_q3[key].reset_index(drop=True)


class SimMeshData:
    def __init__(self, filename):
        # Get first valid index (skip first cell?)
        index = skip_nan_sim_data(filename)

        # Handle simulation mesh data (skip rows integer is 1 more than index)
        raw_data = np.loadtxt(filename, skiprows=index + 1, delimiter=",")

        # Find out if any other indices correspond to nan-values in
        # distance and remove them
        more_nan = np.where(np.isnan(raw_data[:, 8]))[0]
        raw_data = np.delete(raw_data, more_nan, axis=0)

        # Assign necessary values
        self.dist = raw_data[:, 8] / c.R_sun.value
        self.vr = cart_to_rad_vel(raw_data) * 1e-3
        self.np = sim_rho_to_rho(raw_data)
        self.T = 10 ** raw_data[:, 3]

        # COMPUTE DERIVED VALUES (MASS LOSS AND RAM PRESSURE)
        si_density = 10 ** raw_data[:, 6]

        # Compute massloss rate from values in M_sol / year
        self.massloss = massloss(self.dist * c.R_sun.value,
                                 self.vr * 1e3,
                                 si_density)

        # Compute Ram pressure values
        self.rampressure = si_density * (self.vr * 1e3) ** 2


def cut_stat_data(stat_df) -> None:
    """Trim stat data to radial distances less then 40 Rs"""
    # Mark all indices of data frame where radial distance bin location
    # is above 40 Rs (the outer boundary of the simulation domain)
    crit_ind = stat_df.dist.index[stat_df.dist > 40.0]

    # Loop over all attributes of the stat. data object. It has the
    # structure: STATClass.attr.stat_type.DataFrame
    top_keys = stat_df.__dict__.keys()

    for key in top_keys:
        # This object might be a pandas Series or a subclass
        sub_obj = getattr(stat_df, key)

        # If "mean" is part of the keys, the object is a subclass
        if 'mean' in sub_obj.__dict__.keys():
            for key2 in sub_obj.__dict__.keys():
                sub_obj_2 = getattr(sub_obj, key2)
                sub_obj_2.drop(index=crit_ind, inplace=True)

        # Otherwise, the object itself can be reduced
        else:
            sub_obj.drop(index=crit_ind, inplace=True)

    return None


def skip_nan_sim_data(filename):
    """
    Skip entries in data file with NaN-values. This is a result of
    the radial profile generated by paraview starting at R = 0, whereas
    the domain starts at R = 1 R_s
    """
    # First always skipped because of header
    raw_data = np.loadtxt(filename, skiprows=1, delimiter=",")

    # Find first valid primary index
    first_value = 0
    while True:
        if np.isnan(raw_data[first_value][0]):
            first_value += 1
        else:
            return first_value


def cart_to_rad_vel(raw_data):
    """Cartesian velocity components transformed to radial velocity"""
    vx = raw_data[:, 12]
    vy = raw_data[:, 13]
    vz = raw_data[:, 14]
    theta = raw_data[:, 9]
    phi = raw_data[:, 10]

    vr = vx * np.sin(theta) * np.cos(phi) + \
         vy * np.sin(theta) * np.sin(phi) + \
         vz * np.cos(theta)

    return vr


def sim_rho_to_rho(raw_data):
    """Transforms logarithmic SI values into linear CGS values"""
    log_rho = raw_data[:, 6]
    rho = 10 ** log_rho / c.m_p.value * 1e-6

    return rho


def massloss(distance, velocity, density):
    """Mass loss rate in solar masses per year"""
    ml = 4 * np.pi * distance ** 2 * velocity * density

    return ml / c.M_sun.value * (3600 * 24 * 365)


def massloss_interpolate(directory):
    """Read in individual mass loss contour files"""
    distance_values = np.array([])
    massloss_values = np.array([])

    for file in os.listdir(directory):
        # Cut-off ".csv"
        distance = float(file[:-4]) / c.R_sun.value

        mom_den = massloss_from_contour(f"{directory}/{file}")
        mass_loss = mom_den * 31557600 / c.M_sun.value

        distance_values = np.append(distance_values, distance)
        massloss_values = np.append(massloss_values, mass_loss)

    return distance_values, massloss_values


def massloss_from_contour(filename):
    """
    Read in massloss rate from surface contour generated with ParaView
    """

    raw_data = np.loadtxt(filename, skiprows=1, delimiter=",")

    return raw_data[10]
