import numpy as np
import astropy.constants as c


class PSPStatData:
	def __init__(self, filename, sim_data):
		raw_data = np.loadtxt(filename, skiprows=1)
		
		# Correct for maximum distance of simulation data
		co_index = np.where(raw_data[:, 0] >= sim_data.dist[-1])[0][0]
		raw_data = raw_data[:co_index]
		
		# Positional data
		self.dist = raw_data[:, 0]
		
		# Create sub-classes which contain necessary stat data
		self.vr = StatDataSplit(raw_data, 1)
		self.np = StatDataSplit(raw_data, 6)
		self.T = StatDataSplit(raw_data, 11)
		
		# BRIEFLY CALCULATE MASS LOSS RATE (FIX THIS UP)
		class MassLoss:
			def __init__(self, dist, vr, nump):
				self.mean = massloss(dist * c.R_sun.value,
				                     vr.mean * 1e3,
				                     nump.mean * c.m_p.value * 1e6)
				self.stddev = massloss(dist * c.R_sun.value,
				                       vr.stddev * 1e3,
				                       nump.mean * c.m_p.value * 1e6) + \
				              massloss(
					              dist * c.R_sun.value,
					              vr.mean * 1e3,
					              nump.stddev * c.m_p.value * 1e6)
				
		self.massloss = MassLoss(self.dist, self.vr, self.np)
		
		# RAM PRESSURE
		class RamPressure:
			def __init__(self, vr, nump):
				self.mean = (vr.mean * 1e3) ** 2 * \
				            nump.mean * c.m_p.value * 1e6
				
				self.stddev = (vr.mean * 1e3) ** 2 * \
				              nump.stddev * c.m_p.value * 1e6 + \
							  2 * (vr.stddev * 1e3) * \
							  nump.mean * c.m_p.value * 1e6
		
		self.rampressure = RamPressure(self.vr, self.np)


class StatDataSplit:
	"""Sub-class to access relevant statistical data"""
	def __init__(self, raw_data_array, first_index):
		self.mean = raw_data_array[:, first_index]
		self.stddev = raw_data_array[:, first_index + 1]
		self.median = raw_data_array[:, first_index + 2]
		self.q1 = raw_data_array[:, first_index + 3]
		self.q3 = raw_data_array[:, first_index + 4]


class SimMeshData:
	def __init__(self, filename):
		# Get first valid index (skip first cell?)
		index = skip_nan_simdata(filename)
		
		# Handle simulation mesh data (skip rows integer is 1 more than index)
		raw_data = np.loadtxt(filename, skiprows=index + 1, delimiter=",")
		
		# Find out if any other indices correspond to nan-values in
		# distance and remove them
		more_nan = np.where(np.isnan(raw_data[:, 8]))[0]
		raw_data = np.delete(raw_data, more_nan, axis=0)
		
		# Assign necessary values
		self.dist = raw_data[:, 8] / c.R_sun.value
		self.vr = cart_to_rad_vel(raw_data) * 1e-3
		self.np = simrho_to_rho(raw_data)
		self.T = 10 ** raw_data[:, 3]
		
		# COMPUTE DERIVED VALUES (MASS LOSS AND RAM PRESSURE)
		si_density = 10 ** raw_data[:, 6]
		
		# Compute massloss rate from values in Msol / year
		self.massloss = massloss(self.dist * c.R_sun.value,
		                         self.vr * 1e3,
		                         si_density)
		
		# Compute Ram pressure values
		self.rampressure = si_density * (self.vr * 1e3) ** 2
		
		
def skip_nan_simdata(filename):
	"""
	Skip entries in data file with NaN-values. This is a result of
	the radial profile generated by paraview starting at R = 0, whereas
	the domain starts at R = 1 R_s
	"""
	# First always skipped because of header
	raw_data = np.loadtxt(filename, skiprows=1, delimiter=",")
	
	# Find first valid primary index
	first_value = 0
	while True:
		if np.isnan(raw_data[first_value][0]):
			first_value += 1
		else:
			return first_value


def cart_to_rad_vel(raw_data):
	"""Cartesian velocity components transformed to radial velocity"""
	vx = raw_data[:, 12]
	vy = raw_data[:, 13]
	vz = raw_data[:, 14]
	theta = raw_data[:, 9]
	phi = raw_data[:, 10]
	
	vr = vx * np.sin(theta) * np.cos(phi) + \
	     vy * np.sin(theta) * np.sin(phi) + \
	     vz * np.cos(theta)
	
	return vr


def simrho_to_rho(raw_data):
	"""Transforms logarithmic SI values into linear CGS values"""
	lrho = raw_data[:, 6]
	rho = 10 ** lrho / c.m_p.value * 1e-6
	
	return rho


def massloss(distance, velocity, density):
	"""Mass loss rate in solar masses per year"""
	ml = 4 * np.pi * distance ** 2 * velocity * density
	
	return ml / c.M_sun.value * (3600 * 24 * 365)
	