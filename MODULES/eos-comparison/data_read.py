import numpy as np
import astropy.constants as c


class SimMeshData:
    def __init__(self, filename):
        # Get first valid index (skip first cell?)
        index = skip_nan_sim_data(filename)

        # Handle simulation mesh data (skip rows integer is 1 more than index)
        raw_data = np.loadtxt(filename, skiprows=index + 1, delimiter=",")

        # Find out if any other indices correspond to nan-values in
        # distance and remove them
        more_nan = np.where(np.isnan(raw_data[:, 8]))[0]
        raw_data = np.delete(raw_data, more_nan, axis=0)

        # Assign necessary values
        self.dist = raw_data[:, 8] / c.R_sun.value
        self.vr = cart_to_rad_vel(raw_data) * 1e-3
        self.np = sim_rho_to_rho(raw_data)
        self.T = 10 ** raw_data[:, 3]

        # COMPUTE DERIVED VALUES (MASS LOSS AND RAM PRESSURE)
        si_density = 10 ** raw_data[:, 6]

        # Compute massloss rate from values in M_sol / year
        self.massloss = massloss(self.dist * c.R_sun.value,
                                 self.vr * 1e3,
                                 si_density)

        # Compute Ram pressure values
        self.rampressure = si_density * (self.vr * 1e3) ** 2


def skip_nan_sim_data(filename):
    """
    Skip entries in data file with NaN-values. This is a result of
    the radial profile generated by paraview starting at R = 0, whereas
    the domain starts at R = 1 R_s
    """
    # First always skipped because of header
    raw_data = np.loadtxt(filename, skiprows=1, delimiter=",")

    # Find first valid primary index
    first_value = 0
    while True:
        if np.isnan(raw_data[first_value][0]):
            first_value += 1
        else:
            return first_value


def cart_to_rad_vel(raw_data):
    """Cartesian velocity components transformed to radial velocity"""
    vx = raw_data[:, 12]
    vy = raw_data[:, 13]
    vz = raw_data[:, 14]
    theta = raw_data[:, 9]
    phi = raw_data[:, 10]

    vr = vx * np.sin(theta) * np.cos(phi) + \
         vy * np.sin(theta) * np.sin(phi) + \
         vz * np.cos(theta)

    return vr


def sim_rho_to_rho(raw_data):
    """Transforms logarithmic SI values into linear CGS values"""
    log_rho = raw_data[:, 6]
    rho = 10 ** log_rho / c.m_p.value * 1e-6

    return rho


def massloss(distance, velocity, density):
    """Mass loss rate in solar masses per year"""
    ml = 4 * np.pi * distance ** 2 * velocity * density

    return ml / c.M_sun.value * (3600 * 24 * 365)
